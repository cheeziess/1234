<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Chatbot Dapur Inoy</title>

  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f2f2f2;
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }

    #chat-container {
      width: 100%;
      max-width: 430px;
      height: 90vh;
      background: white;
      border-radius: 12px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    #header {
      background: #8b2e2e;
      color: white;
      padding: 15px;
      font-size: 20px;
      font-weight: bold;
      text-align: center;
    }

    #messages {
      flex: 1;
      padding: 15px;
      overflow-y: auto;
      background: #fafafa;
    }

    .msg {
      margin: 10px 0;
      max-width: 80%;
      padding: 10px 15px;
      border-radius: 12px;
      line-height: 1.4;
      font-size: 15px;
    }

    .me {
      background: #d1e7ff;
      color: #003366;
      margin-left: auto;
      border-bottom-right-radius: 0;
    }

    .bot {
      background: #eee;
      color: #333;
      margin-right: auto;
      border-bottom-left-radius: 0;
    }

    #input-area {
      display: flex;
      border-top: 1px solid #ddd;
    }

    #userInput {
      flex: 1;
      padding: 12px;
      border: none;
      outline: none;
      font-size: 16px;
    }

    #sendBtn {
      background: #8b2e2e;
      color: white;
      border: none;
      padding: 0 20px;
      cursor: pointer;
      font-size: 16px;
    }

    #sendBtn:hover {
      background: #7a2626;
    }
  </style>
</head>

<body>

  <div id="chat-container">
    <div id="header">Chat Dapur Inoy</div>

    <div id="messages"></div>

    <div id="input-area">
      <input id="userInput" type="text" placeholder="Tulis pesan..." />
      <button id="sendBtn" onclick="sendMessage()">Kirim</button>
    </div>
  </div>

  <script>
    const webhookURL = "https://wertetete.app.n8n.cloud/webhook/chatbot";

    const messagesEl = document.getElementById("messages");
    const inputEl = document.getElementById("userInput");

    function addMessage(text, who) {
      const div = document.createElement("div");
      div.className = `msg ${who}`;
      div.textContent = text;
      messagesEl.appendChild(div);
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    function addTyping() {
      const div = document.createElement("div");
      div.className = "msg bot";
      div.id = "typingIndicator";
      div.textContent = "â€¢â€¢â€¢";
      div.style.opacity = "0.5";
      messagesEl.appendChild(div);
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    function removeTyping() {
      const typing = document.getElementById("typingIndicator");
      if (typing) typing.remove();
    }

    // Normalize possible double-encoded / nested JSON responses into a usable string
    function normalizeReply(body) {
      if (body === null || body === undefined) return null;

      function extractJsonSubstring(s) {
        const firstObj = s.indexOf('{'), lastObj = s.lastIndexOf('}');
        if (firstObj !== -1 && lastObj !== -1 && lastObj > firstObj) return s.slice(firstObj, lastObj + 1);
        const firstArr = s.indexOf('['), lastArr = s.lastIndexOf(']');
        if (firstArr !== -1 && lastArr !== -1 && lastArr > firstArr) return s.slice(firstArr, lastArr + 1);
        return null;
      }

      function cleanString(s) {
        if (typeof s !== 'string') return s;
        // remove leading equals or stray braces, unescape common sequences
        s = s.replace(/^[=\s\r\n]+/, '').trim();
        s = s.replace(/\\n/g, '\n').replace(/\\"/g, '"').replace(/\\'/g, "'");
        // collapse repeated whitespace
        s = s.replace(/\s{2,}/g, ' ').trim();
        return s;
      }

      function attempt(val, depth = 0) {
        if (depth > 6) return null;
        if (val === null || val === undefined) return null;

        if (typeof val === 'string') {
          let s = cleanString(val);
          // Try direct JSON parse multiple times
          for (let i = 0; i < 3; i++) {
            try {
              const p = JSON.parse(s);
              return attempt(p, depth + 1);
            } catch {}
            // try extracting a JSON-looking substring and parse
            const sub = extractJsonSubstring(s);
            if (sub && sub !== s) {
              try {
                const p2 = JSON.parse(sub);
                return attempt(p2, depth + 1);
              } catch {}
            }
            break;
          }
          // Try regex to capture "reply": "..."
          const m = s.match(/"reply"\s*:\s*"([\s\S]*?)"/);
          if (m && m[1]) return cleanString(m[1]);
          // If looks like object encoded as key (e.g. '{"reply": "...":{'), try to extract between first "reply" and next ":"
          const m2 = s.match(/"reply"\s*:\s*([^,}\]]+)/);
          if (m2 && m2[1]) return cleanString(m2[1].replace(/^["']|["']$/g, ''));
          // fallback: return cleaned raw string
          return s;
        }

        if (typeof val === 'object') {
          // common keys
          const keys = ['reply', 'message', 'response', 'output', 'text', 'me'];
          for (const k of keys) {
            if (k in val) {
              const r = attempt(val[k], depth + 1);
              if (r) return r;
            }
          }
          // sometimes the key itself contains JSON; try parsing keys
          for (const key of Object.keys(val)) {
            if (typeof key === 'string' && (key.includes('"reply"') || key.includes('reply'))) {
              const parsed = attempt(key, depth + 1);
              if (parsed) return parsed;
            }
            const r = attempt(val[key], depth + 1);
            if (r) return r;
          }
          // last resort: stringify then try to extract reply
          try {
            const s = JSON.stringify(val);
            return attempt(s, depth + 1);
          } catch {}
        }
        return String(val);
      }

      return attempt(body) ?? null;
    }

    // new: extract only the value under the "output" key (searches nested/stringified JSON)
    function extractOutputOnly(body) {
      if (body === null || body === undefined) return null;

      function tryExtract(val, depth = 0) {
        if (depth > 6 || val === null || val === undefined) return null;

        // If string, try to parse JSON then continue searching
        if (typeof val === 'string') {
          const s = val.trim();
          try {
            const p = JSON.parse(s);
            return tryExtract(p, depth + 1);
          } catch {}
          // try to extract a JSON-looking substring
          const firstObj = s.indexOf('{'), lastObj = s.lastIndexOf('}');
          if (firstObj !== -1 && lastObj !== -1 && lastObj > firstObj) {
            try {
              const sub = s.slice(firstObj, lastObj + 1);
              const p2 = JSON.parse(sub);
              return tryExtract(p2, depth + 1);
            } catch {}
          }
          return null;
        }

        if (typeof val === 'object') {
          // direct match
          if (Object.prototype.hasOwnProperty.call(val, 'output')) return val['output'];
          // recurse into properties
          for (const k of Object.keys(val)) {
            const r = tryExtract(val[k], depth + 1);
            if (r !== null && r !== undefined) return r;
          }
        }

        return null;
      }

      const found = tryExtract(body);
      if (found === null || found === undefined) return null;
      // If the found value is complex, normalize it to a string for display
      return normalizeReply(found) ?? String(found);
    }

    async function sendMessage() {
      const text = inputEl.value.trim();
      if (!text) return;

      addMessage(text, "me");
      inputEl.value = "";

      addTyping();

      try {
        const res = await fetch(webhookURL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ message: text })
        });

        // Try to parse body as JSON, fallback to text
        let body;
        const ct = res.headers.get("content-type") || "";
        try {
          if (ct.includes("application/json")) {
            body = await res.json();
          } else {
            const txt = await res.text();
            try {
              body = JSON.parse(txt);
            } catch {
              body = txt;
            }
          }
        } catch (parseErr) {
          // Last fallback: text()
          body = await res.text().catch(() => null);
        }

        removeTyping();

        // If HTTP status not ok, show status + body for debug
        if (!res.ok) {
          console.error("HTTP error", res.status, body);
          addMessage(`Server mengembalikan error ${res.status}.`, "bot");
          return;
        }

        console.log("Webhook response:", body);

        // prefer only the JSON value under "output"
        const reply = extractOutputOnly(body) || "(tidak ada balasan)";

        addMessage(reply, "bot");
      } catch (err) {
        console.error("Fetch error:", err);
        removeTyping();
        addMessage("Maaf, terjadi kesalahan koneksi.", "bot");
      }
    }

    // Enter untuk kirim
    inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") sendMessage();
    });

    // Greeting awal
    addMessage("Halo! Ada yang bisa saya bantu tentang risol Dapur Inoy? ðŸ˜Š", "bot");
  </script>

</body>
</html>
